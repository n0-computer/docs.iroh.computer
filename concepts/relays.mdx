---
title: "Relays"
---

Relays are servers that help establish connections between devices. 

Relays temporarily route encrypted traffic until a direct, P2P connection is
feasible. Once this direct path is set up, the relay server steps back, and the
data flows directly between devices. This approach allows Iroh to maintain a
secure, low-latency connection, even in challenging network situations.

Relays are also open source! You can run your own relay server, or use one of
the public relays. Code is
[here](https://github.com/n0-computer/iroh/tree/main/iroh-relay), and we build
relay binaries for most platforms with each iroh
[release](https://github.com/n0-computer/iroh/releases)

There are situations where a direct connection _can't_ be established, and in those cases traffic falls back to running through the relay. Relay servers **do not** have access to the data being transmitted, as it's encrypted end-to-end.

We're working on formally collecting the direct connection rate from production iroh networks. Anecdotal evidence points to the holepunching rate being around 90%, meaning 9 out of 10 times, a direct connection is established.

### Why this architecture is powerful

This approach makes uptime management significantly easier compared to
traditional client-server architectures:

**Stateless servers, stateful clients**  
Unlike traditional servers that store your application's data and state, relay
servers are just connection facilitators. All your business logic and data lives
in your clients. This means:

- **No database synchronization** - You don't need to worry about keeping multiple server databases in sync or handling data replication
- **No state migration** - When a relay goes down, clients simply reconnect to another relay without any data loss or state transfer
- **Simple server management** - Relay servers are lightweight and easy to spin up or down. No complex deployment procedures or data migration steps

**Automatic failover**  
iroh clients automatically try multiple relays when connecting. If one relay is unavailable, clients seamlessly fall back to another relay in your list without application-level retry logic. Your peers will find each other as long as at least one relay is reachable.

**Multi-cloud resilience**  
For even better guarantees, you can distribute relays across multiple cloud providers. If one provider experiences an outage, your application keeps running on relays hosted elsewhere. Since relays don't store state, you can freely mix providers without worrying about cross-cloud data consistency.

**Cost-effective scaling**  
Adding capacity means spinning up more lightweight relay instances, not provisioning databases or managing complex stateful server infrastructure. You can easily scale up for peak usage and scale down during quiet periods.

This architecture inverts the traditional model: instead of treating servers as precious stateful resources and clients as disposable, relay-based architectures treat relays as disposable connection facilitators while clients own the application state and logic.

## Connection Changes

During the lifespan of a connection, networking conditions can change, for
example when a user switched from 5G to WiFi, plugs in an ethernet cable, or a
sysadmin modifies router configurations. The connection may change from direct
to relayed, or even a mixed combination of the two. Iroh will automatically
switch between direct and relayed connections as needed, without any action
required from the application.

## number 0 public relays

number 0 provides a set of public relays that are free to use, and are
configured by default. You're more than welcome to run production systems using
the public relays if you find performance acceptable. The public relays do
rate-limit traffic that flows through the relay. This is to prevent abuse, and
ensure the relays are available to everyone. If you need more capacity, you can
run your own relay server, or [contact us about a custom relay
setup](https://n0.computer/n0ps/).
